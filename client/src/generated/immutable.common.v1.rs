// This file is @generated by prost-build.
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PathFormat {
    Unspecified = 0,
    Bip32 = 1,
}
impl PathFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PATH_FORMAT_UNSPECIFIED",
            Self::Bip32 => "PATH_FORMAT_BIP32",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PATH_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "PATH_FORMAT_BIP32" => Some(Self::Bip32),
            _ => None,
        }
    }
}
/// Cryptographic Curve used to generate a given API key
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApiKeyCurve {
    Unspecified = 0,
    P256 = 2,
    Secp256k1 = 3,
    Ed25519 = 4,
}
impl ApiKeyCurve {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "API_KEY_CURVE_UNSPECIFIED",
            Self::P256 => "API_KEY_CURVE_P256",
            Self::Secp256k1 => "API_KEY_CURVE_SECP256K1",
            Self::Ed25519 => "API_KEY_CURVE_ED25519",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "API_KEY_CURVE_UNSPECIFIED" => Some(Self::Unspecified),
            "API_KEY_CURVE_P256" => Some(Self::P256),
            "API_KEY_CURVE_SECP256K1" => Some(Self::Secp256k1),
            "API_KEY_CURVE_ED25519" => Some(Self::Ed25519),
            _ => None,
        }
    }
}
/// Cryptographic Curve used to generate a given Private Key.
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Curve {
    Unspecified = 0,
    Secp256k1 = 1,
    Ed25519 = 2,
}
impl Curve {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CURVE_UNSPECIFIED",
            Self::Secp256k1 => "CURVE_SECP256K1",
            Self::Ed25519 => "CURVE_ED25519",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CURVE_UNSPECIFIED" => Some(Self::Unspecified),
            "CURVE_SECP256K1" => Some(Self::Secp256k1),
            "CURVE_ED25519" => Some(Self::Ed25519),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddressFormat {
    Unspecified = 0,
    /// 04<X_COORDINATE><Y_COORDINATE>
    Uncompressed = 1,
    /// 02 or 03, followed by the X coordinate
    Compressed = 2,
    Ethereum = 3,
    Solana = 4,
    Cosmos = 5,
    Tron = 6,
    Sui = 7,
    Aptos = 8,
    /// Bitcoin Mainnet address types
    BitcoinMainnetP2pkh = 9,
    BitcoinMainnetP2sh = 10,
    BitcoinMainnetP2wpkh = 11,
    BitcoinMainnetP2wsh = 12,
    BitcoinMainnetP2tr = 13,
    /// Bitcoin Testnet address types
    BitcoinTestnetP2pkh = 14,
    BitcoinTestnetP2sh = 15,
    BitcoinTestnetP2wpkh = 16,
    BitcoinTestnetP2wsh = 17,
    BitcoinTestnetP2tr = 18,
    /// Bitcoin Signet address types
    BitcoinSignetP2pkh = 19,
    BitcoinSignetP2sh = 20,
    BitcoinSignetP2wpkh = 21,
    BitcoinSignetP2wsh = 22,
    BitcoinSignetP2tr = 23,
    /// Bitcoin Regtest address types
    BitcoinRegtestP2pkh = 24,
    BitcoinRegtestP2sh = 25,
    BitcoinRegtestP2wpkh = 26,
    BitcoinRegtestP2wsh = 27,
    BitcoinRegtestP2tr = 28,
    Sei = 29,
    Xlm = 30,
    /// Doge Addresses
    DogeMainnet = 31,
    DogeTestnet = 32,
    /// TON Addresses
    TonV3r2 = 33,
    TonV4r2 = 34,
    Xrp = 35,
}
impl AddressFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ADDRESS_FORMAT_UNSPECIFIED",
            Self::Uncompressed => "ADDRESS_FORMAT_UNCOMPRESSED",
            Self::Compressed => "ADDRESS_FORMAT_COMPRESSED",
            Self::Ethereum => "ADDRESS_FORMAT_ETHEREUM",
            Self::Solana => "ADDRESS_FORMAT_SOLANA",
            Self::Cosmos => "ADDRESS_FORMAT_COSMOS",
            Self::Tron => "ADDRESS_FORMAT_TRON",
            Self::Sui => "ADDRESS_FORMAT_SUI",
            Self::Aptos => "ADDRESS_FORMAT_APTOS",
            Self::BitcoinMainnetP2pkh => "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH",
            Self::BitcoinMainnetP2sh => "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH",
            Self::BitcoinMainnetP2wpkh => "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH",
            Self::BitcoinMainnetP2wsh => "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH",
            Self::BitcoinMainnetP2tr => "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR",
            Self::BitcoinTestnetP2pkh => "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH",
            Self::BitcoinTestnetP2sh => "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH",
            Self::BitcoinTestnetP2wpkh => "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH",
            Self::BitcoinTestnetP2wsh => "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH",
            Self::BitcoinTestnetP2tr => "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR",
            Self::BitcoinSignetP2pkh => "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH",
            Self::BitcoinSignetP2sh => "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH",
            Self::BitcoinSignetP2wpkh => "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH",
            Self::BitcoinSignetP2wsh => "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH",
            Self::BitcoinSignetP2tr => "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR",
            Self::BitcoinRegtestP2pkh => "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH",
            Self::BitcoinRegtestP2sh => "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH",
            Self::BitcoinRegtestP2wpkh => "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH",
            Self::BitcoinRegtestP2wsh => "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH",
            Self::BitcoinRegtestP2tr => "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR",
            Self::Sei => "ADDRESS_FORMAT_SEI",
            Self::Xlm => "ADDRESS_FORMAT_XLM",
            Self::DogeMainnet => "ADDRESS_FORMAT_DOGE_MAINNET",
            Self::DogeTestnet => "ADDRESS_FORMAT_DOGE_TESTNET",
            Self::TonV3r2 => "ADDRESS_FORMAT_TON_V3R2",
            Self::TonV4r2 => "ADDRESS_FORMAT_TON_V4R2",
            Self::Xrp => "ADDRESS_FORMAT_XRP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADDRESS_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "ADDRESS_FORMAT_UNCOMPRESSED" => Some(Self::Uncompressed),
            "ADDRESS_FORMAT_COMPRESSED" => Some(Self::Compressed),
            "ADDRESS_FORMAT_ETHEREUM" => Some(Self::Ethereum),
            "ADDRESS_FORMAT_SOLANA" => Some(Self::Solana),
            "ADDRESS_FORMAT_COSMOS" => Some(Self::Cosmos),
            "ADDRESS_FORMAT_TRON" => Some(Self::Tron),
            "ADDRESS_FORMAT_SUI" => Some(Self::Sui),
            "ADDRESS_FORMAT_APTOS" => Some(Self::Aptos),
            "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH" => Some(Self::BitcoinMainnetP2pkh),
            "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH" => Some(Self::BitcoinMainnetP2sh),
            "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH" => Some(Self::BitcoinMainnetP2wpkh),
            "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH" => Some(Self::BitcoinMainnetP2wsh),
            "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR" => Some(Self::BitcoinMainnetP2tr),
            "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH" => Some(Self::BitcoinTestnetP2pkh),
            "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH" => Some(Self::BitcoinTestnetP2sh),
            "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH" => Some(Self::BitcoinTestnetP2wpkh),
            "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH" => Some(Self::BitcoinTestnetP2wsh),
            "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR" => Some(Self::BitcoinTestnetP2tr),
            "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH" => Some(Self::BitcoinSignetP2pkh),
            "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH" => Some(Self::BitcoinSignetP2sh),
            "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH" => Some(Self::BitcoinSignetP2wpkh),
            "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH" => Some(Self::BitcoinSignetP2wsh),
            "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR" => Some(Self::BitcoinSignetP2tr),
            "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH" => Some(Self::BitcoinRegtestP2pkh),
            "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH" => Some(Self::BitcoinRegtestP2sh),
            "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH" => Some(Self::BitcoinRegtestP2wpkh),
            "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH" => Some(Self::BitcoinRegtestP2wsh),
            "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR" => Some(Self::BitcoinRegtestP2tr),
            "ADDRESS_FORMAT_SEI" => Some(Self::Sei),
            "ADDRESS_FORMAT_XLM" => Some(Self::Xlm),
            "ADDRESS_FORMAT_DOGE_MAINNET" => Some(Self::DogeMainnet),
            "ADDRESS_FORMAT_DOGE_TESTNET" => Some(Self::DogeTestnet),
            "ADDRESS_FORMAT_TON_V3R2" => Some(Self::TonV3r2),
            "ADDRESS_FORMAT_TON_V4R2" => Some(Self::TonV4r2),
            "ADDRESS_FORMAT_XRP" => Some(Self::Xrp),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashFunction {
    Unspecified = 0,
    NoOp = 1,
    Sha256 = 2,
    Keccak256 = 3,
    NotApplicable = 4,
}
impl HashFunction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HASH_FUNCTION_UNSPECIFIED",
            Self::NoOp => "HASH_FUNCTION_NO_OP",
            Self::Sha256 => "HASH_FUNCTION_SHA256",
            Self::Keccak256 => "HASH_FUNCTION_KECCAK256",
            Self::NotApplicable => "HASH_FUNCTION_NOT_APPLICABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASH_FUNCTION_UNSPECIFIED" => Some(Self::Unspecified),
            "HASH_FUNCTION_NO_OP" => Some(Self::NoOp),
            "HASH_FUNCTION_SHA256" => Some(Self::Sha256),
            "HASH_FUNCTION_KECCAK256" => Some(Self::Keccak256),
            "HASH_FUNCTION_NOT_APPLICABLE" => Some(Self::NotApplicable),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayloadEncoding {
    /// Default value if payload encoding is not set explicitly
    Unspecified = 0,
    /// Payload is encoded in hexadecimal
    /// We accept 0x-prefixed or non-0x prefixed payloads.
    /// We accept any casing (uppercase, lowercase, or mixed)
    Hexadecimal = 1,
    /// Payload is encoded as utf-8 text
    /// Will be converted to bytes for signature with Rust's standard String.as_bytes()
    TextUtf8 = 2,
}
impl PayloadEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PAYLOAD_ENCODING_UNSPECIFIED",
            Self::Hexadecimal => "PAYLOAD_ENCODING_HEXADECIMAL",
            Self::TextUtf8 => "PAYLOAD_ENCODING_TEXT_UTF8",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYLOAD_ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "PAYLOAD_ENCODING_HEXADECIMAL" => Some(Self::Hexadecimal),
            "PAYLOAD_ENCODING_TEXT_UTF8" => Some(Self::TextUtf8),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MnemonicLanguage {
    Unspecified = 0,
    English = 1,
    SimplifiedChinese = 2,
    TraditionalChinese = 3,
    Czech = 4,
    French = 5,
    Italian = 6,
    Japanese = 7,
    Korean = 8,
    Spanish = 9,
}
impl MnemonicLanguage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MNEMONIC_LANGUAGE_UNSPECIFIED",
            Self::English => "MNEMONIC_LANGUAGE_ENGLISH",
            Self::SimplifiedChinese => "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE",
            Self::TraditionalChinese => "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE",
            Self::Czech => "MNEMONIC_LANGUAGE_CZECH",
            Self::French => "MNEMONIC_LANGUAGE_FRENCH",
            Self::Italian => "MNEMONIC_LANGUAGE_ITALIAN",
            Self::Japanese => "MNEMONIC_LANGUAGE_JAPANESE",
            Self::Korean => "MNEMONIC_LANGUAGE_KOREAN",
            Self::Spanish => "MNEMONIC_LANGUAGE_SPANISH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MNEMONIC_LANGUAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "MNEMONIC_LANGUAGE_ENGLISH" => Some(Self::English),
            "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE" => Some(Self::SimplifiedChinese),
            "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE" => Some(Self::TraditionalChinese),
            "MNEMONIC_LANGUAGE_CZECH" => Some(Self::Czech),
            "MNEMONIC_LANGUAGE_FRENCH" => Some(Self::French),
            "MNEMONIC_LANGUAGE_ITALIAN" => Some(Self::Italian),
            "MNEMONIC_LANGUAGE_JAPANESE" => Some(Self::Japanese),
            "MNEMONIC_LANGUAGE_KOREAN" => Some(Self::Korean),
            "MNEMONIC_LANGUAGE_SPANISH" => Some(Self::Spanish),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Effect {
    Unspecified = 0,
    Allow = 1,
    Deny = 2,
}
impl Effect {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EFFECT_UNSPECIFIED",
            Self::Allow => "EFFECT_ALLOW",
            Self::Deny => "EFFECT_DENY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EFFECT_UNSPECIFIED" => Some(Self::Unspecified),
            "EFFECT_ALLOW" => Some(Self::Allow),
            "EFFECT_DENY" => Some(Self::Deny),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AccessType {
    Unspecified = 0,
    Web = 1,
    Api = 2,
    All = 3,
}
impl AccessType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACCESS_TYPE_UNSPECIFIED",
            Self::Web => "ACCESS_TYPE_WEB",
            Self::Api => "ACCESS_TYPE_API",
            Self::All => "ACCESS_TYPE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCESS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCESS_TYPE_WEB" => Some(Self::Web),
            "ACCESS_TYPE_API" => Some(Self::Api),
            "ACCESS_TYPE_ALL" => Some(Self::All),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CredentialType {
    Unspecified = 0,
    WebauthnAuthenticator = 1,
    ApiKeyP256 = 2,
    RecoverUserKeyP256 = 3,
    ApiKeySecp256k1 = 4,
    EmailAuthKeyP256 = 5,
    ApiKeyEd25519 = 6,
    OtpAuthKeyP256 = 7,
    ReadWriteSessionKeyP256 = 8,
    OauthKeyP256 = 9,
}
impl CredentialType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CREDENTIAL_TYPE_UNSPECIFIED",
            Self::WebauthnAuthenticator => "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR",
            Self::ApiKeyP256 => "CREDENTIAL_TYPE_API_KEY_P256",
            Self::RecoverUserKeyP256 => "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256",
            Self::ApiKeySecp256k1 => "CREDENTIAL_TYPE_API_KEY_SECP256K1",
            Self::EmailAuthKeyP256 => "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256",
            Self::ApiKeyEd25519 => "CREDENTIAL_TYPE_API_KEY_ED25519",
            Self::OtpAuthKeyP256 => "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256",
            Self::ReadWriteSessionKeyP256 => {
                "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
            }
            Self::OauthKeyP256 => "CREDENTIAL_TYPE_OAUTH_KEY_P256",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREDENTIAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR" => Some(Self::WebauthnAuthenticator),
            "CREDENTIAL_TYPE_API_KEY_P256" => Some(Self::ApiKeyP256),
            "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256" => Some(Self::RecoverUserKeyP256),
            "CREDENTIAL_TYPE_API_KEY_SECP256K1" => Some(Self::ApiKeySecp256k1),
            "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256" => Some(Self::EmailAuthKeyP256),
            "CREDENTIAL_TYPE_API_KEY_ED25519" => Some(Self::ApiKeyEd25519),
            "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256" => Some(Self::OtpAuthKeyP256),
            "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256" => {
                Some(Self::ReadWriteSessionKeyP256)
            }
            "CREDENTIAL_TYPE_OAUTH_KEY_P256" => Some(Self::OauthKeyP256),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FeatureName {
    Unspecified = 0,
    /// to be deprecated in favor of rename: `FEATURE_NAME_EMAIL_RECOVERY`
    RootUserEmailRecovery = 1,
    WebauthnOrigins = 2,
    EmailAuth = 3,
    EmailRecovery = 4,
    Webhook = 5,
    SmsAuth = 6,
    OtpEmailAuth = 7,
}
impl FeatureName {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FEATURE_NAME_UNSPECIFIED",
            Self::RootUserEmailRecovery => "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY",
            Self::WebauthnOrigins => "FEATURE_NAME_WEBAUTHN_ORIGINS",
            Self::EmailAuth => "FEATURE_NAME_EMAIL_AUTH",
            Self::EmailRecovery => "FEATURE_NAME_EMAIL_RECOVERY",
            Self::Webhook => "FEATURE_NAME_WEBHOOK",
            Self::SmsAuth => "FEATURE_NAME_SMS_AUTH",
            Self::OtpEmailAuth => "FEATURE_NAME_OTP_EMAIL_AUTH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FEATURE_NAME_UNSPECIFIED" => Some(Self::Unspecified),
            "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY" => Some(Self::RootUserEmailRecovery),
            "FEATURE_NAME_WEBAUTHN_ORIGINS" => Some(Self::WebauthnOrigins),
            "FEATURE_NAME_EMAIL_AUTH" => Some(Self::EmailAuth),
            "FEATURE_NAME_EMAIL_RECOVERY" => Some(Self::EmailRecovery),
            "FEATURE_NAME_WEBHOOK" => Some(Self::Webhook),
            "FEATURE_NAME_SMS_AUTH" => Some(Self::SmsAuth),
            "FEATURE_NAME_OTP_EMAIL_AUTH" => Some(Self::OtpEmailAuth),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionType {
    Unspecified = 0,
    /// Unsigned Ethereum transaction, RLP-encoded and hex-encoded
    Ethereum = 1,
    /// Unsigned Solana transaction in hex bytes
    Solana = 2,
}
impl TransactionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSACTION_TYPE_UNSPECIFIED",
            Self::Ethereum => "TRANSACTION_TYPE_ETHEREUM",
            Self::Solana => "TRANSACTION_TYPE_SOLANA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_TYPE_ETHEREUM" => Some(Self::Ethereum),
            "TRANSACTION_TYPE_SOLANA" => Some(Self::Solana),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Outcome {
    Unspecified = 0,
    Allow = 1,
    DenyExplicit = 2,
    DenyImplicit = 3,
    RequiresConsensus = 4,
    Rejected = 5,
    Error = 6,
}
impl Outcome {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OUTCOME_UNSPECIFIED",
            Self::Allow => "OUTCOME_ALLOW",
            Self::DenyExplicit => "OUTCOME_DENY_EXPLICIT",
            Self::DenyImplicit => "OUTCOME_DENY_IMPLICIT",
            Self::RequiresConsensus => "OUTCOME_REQUIRES_CONSENSUS",
            Self::Rejected => "OUTCOME_REJECTED",
            Self::Error => "OUTCOME_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
            "OUTCOME_ALLOW" => Some(Self::Allow),
            "OUTCOME_DENY_EXPLICIT" => Some(Self::DenyExplicit),
            "OUTCOME_DENY_IMPLICIT" => Some(Self::DenyImplicit),
            "OUTCOME_REQUIRES_CONSENSUS" => Some(Self::RequiresConsensus),
            "OUTCOME_REJECTED" => Some(Self::Rejected),
            "OUTCOME_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operator {
    Unspecified = 0,
    Equal = 1,
    MoreThan = 2,
    MoreThanOrEqual = 3,
    LessThan = 4,
    LessThanOrEqual = 5,
    Contains = 6,
    NotEqual = 7,
    In = 8,
    NotIn = 9,
    ContainsOne = 10,
    ContainsAll = 11,
}
impl Operator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATOR_UNSPECIFIED",
            Self::Equal => "OPERATOR_EQUAL",
            Self::MoreThan => "OPERATOR_MORE_THAN",
            Self::MoreThanOrEqual => "OPERATOR_MORE_THAN_OR_EQUAL",
            Self::LessThan => "OPERATOR_LESS_THAN",
            Self::LessThanOrEqual => "OPERATOR_LESS_THAN_OR_EQUAL",
            Self::Contains => "OPERATOR_CONTAINS",
            Self::NotEqual => "OPERATOR_NOT_EQUAL",
            Self::In => "OPERATOR_IN",
            Self::NotIn => "OPERATOR_NOT_IN",
            Self::ContainsOne => "OPERATOR_CONTAINS_ONE",
            Self::ContainsAll => "OPERATOR_CONTAINS_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
            "OPERATOR_EQUAL" => Some(Self::Equal),
            "OPERATOR_MORE_THAN" => Some(Self::MoreThan),
            "OPERATOR_MORE_THAN_OR_EQUAL" => Some(Self::MoreThanOrEqual),
            "OPERATOR_LESS_THAN" => Some(Self::LessThan),
            "OPERATOR_LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
            "OPERATOR_CONTAINS" => Some(Self::Contains),
            "OPERATOR_NOT_EQUAL" => Some(Self::NotEqual),
            "OPERATOR_IN" => Some(Self::In),
            "OPERATOR_NOT_IN" => Some(Self::NotIn),
            "OPERATOR_CONTAINS_ONE" => Some(Self::ContainsOne),
            "OPERATOR_CONTAINS_ALL" => Some(Self::ContainsAll),
            _ => None,
        }
    }
}
